---
name: tanstack-router
description: |
  Build type-safe, file-based React routing with TanStack Router. Supports client-side navigation, route loaders, and TanStack Query integration. Prevents 20 documented errors including validation structure loss, param parsing bugs, and SSR streaming crashes.

  Use when implementing file-based routing patterns, building SPAs with TypeScript routing, or troubleshooting devtools dependency errors, type safety issues, Vite bundling problems, or Docker deployment issues.
user-invocable: true
---

# TanStack Router

Type-safe, file-based routing for React SPAs with route-level data loading and TanStack Query integration

---

## Quick Start

**Last Updated**: 2026-01-09
**Version**: @tanstack/react-router@1.146.2

```bash
npm install @tanstack/react-router @tanstack/router-devtools
npm install -D @tanstack/router-plugin
# Optional: Zod validation adapter
npm install @tanstack/zod-adapter zod
```

**Vite Config** (TanStackRouterVite MUST come before react()):

```typescript
// vite.config.ts
import { TanStackRouterVite } from "@tanstack/router-plugin/vite";

export default defineConfig({
  plugins: [TanStackRouterVite(), react()], // Order matters!
});
```

**File Structure**:

```
src/routes/
├── __root.tsx         → createRootRoute() with <Outlet />
├── index.tsx          → createFileRoute('/')
└── posts.$postId.tsx  → createFileRoute('/posts/$postId')
```

**App Setup**:

```typescript
import { createRouter, RouterProvider } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen' // Auto-generated by plugin

const router = createRouter({ routeTree })
<RouterProvider router={router} />
```

---

## Core Patterns

**Type-Safe Navigation** (routes auto-complete, params typed):

```typescript
<Link to="/posts/$postId" params={{ postId: '123' }} />
<Link to="/invalid" /> // ❌ TypeScript error
```

**Route Loaders** (data fetching before render):

```typescript
export const Route = createFileRoute('/posts/$postId')({
  loader: async ({ params }) => ({ post: await fetchPost(params.postId) }),
  component: ({ useLoaderData }) => {
    const { post } = useLoaderData() // Fully typed!
    return <h1>{post.title}</h1>
  },
})
```

**TanStack Query Integration** (prefetch + cache):

```typescript
const postOpts = (id: string) => queryOptions({
  queryKey: ['posts', id],
  queryFn: () => fetchPost(id),
})

export const Route = createFileRoute('/posts/$postId')({
  loader: ({ context: { queryClient }, params }) =>
    queryClient.ensureQueryData(postOpts(params.postId)),
  component: () => {
    const { postId } = Route.useParams()
    const { data } = useQuery(postOpts(postId))
    return <h1>{data.title}</h1>
  },
})
```

---

## TanStack Query Integration Examples

Complete patterns for combining TanStack Router with TanStack Query for type-safe data fetching:

### Setup: QueryClient Context

**Router Setup** (pass QueryClient to routes):

```typescript
// src/main.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { createRouter, RouterProvider } from '@tanstack/react-router'
import { routeTree } from './routeTree.gen'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 60, // 1 hour
    },
  },
})

const router = createRouter({
  routeTree,
  context: {
    queryClient, // Pass to all routes
  },
  defaultPreload: 'intent', // Prefetch on hover
})

// Type registration for autocomplete
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <RouterProvider router={router} />
    </QueryClientProvider>
  )
}
```

### Pattern 1: Basic Query + Loader Prefetch

**Route with prefetch** (data ready before component renders):

```typescript
// src/routes/posts.$postId.tsx
import { createFileRoute } from '@tanstack/react-router'
import { queryOptions, useQuery } from '@tanstack/react-query'

// Query factory (reusable)
export const postQueryOptions = (postId: string) =>
  queryOptions({
    queryKey: ['posts', postId],
    queryFn: async () => {
      const res = await fetch(`/api/posts/${postId}`)
      if (!res.ok) throw new Error('Failed to fetch post')
      return res.json() as Promise<Post>
    },
  })

export const Route = createFileRoute('/posts/$postId')({
  // Prefetch in loader (SSR-friendly)
  loader: ({ context: { queryClient }, params }) =>
    queryClient.ensureQueryData(postQueryOptions(params.postId)),

  // Component uses cached data
  component: PostComponent,
})

function PostComponent() {
  const { postId } = Route.useParams()
  const { data, isPending, error } = useQuery(postQueryOptions(postId))

  if (isPending) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <article>
      <h1>{data.title}</h1>
      <p>{data.content}</p>
    </article>
  )
}
```

### Pattern 2: useSuspenseQuery + ErrorBoundary

**Modern pattern** (no loading states needed):

```typescript
// src/routes/posts.$postId.tsx
import { createFileRoute, ErrorComponent } from '@tanstack/react-router'
import { queryOptions, useSuspenseQuery } from '@tanstack/react-query'

export const postQueryOptions = (postId: string) =>
  queryOptions({
    queryKey: ['posts', postId],
    queryFn: async () => {
      const res = await fetch(`/api/posts/${postId}`)
      if (!res.ok) throw new Error('Post not found')
      return res.json() as Promise<Post>
    },
  })

export const Route = createFileRoute('/posts/$postId')({
  loader: ({ context: { queryClient }, params }) =>
    queryClient.ensureQueryData(postQueryOptions(params.postId)),

  component: PostComponent,

  // Automatic error handling
  errorComponent: ({ error, reset }) => (
    <ErrorComponent error={error} reset={reset} />
  ),

  // Custom pending UI
  pendingComponent: () => <div>Loading post...</div>,
})

function PostComponent() {
  const { postId } = Route.useParams()
  // No isPending check needed - Suspense handles it
  const { data } = useSuspenseQuery(postQueryOptions(postId))

  return (
    <article>
      <h1>{data.title}</h1>
      <p>{data.content}</p>
    </article>
  )
}
```

### Pattern 3: List + Mutations with Invalidation

**CRUD operations** with cache invalidation on route change:

```typescript
// src/routes/posts.index.tsx
import { createFileRoute } from '@tanstack/react-router'
import { queryOptions, useQuery, useMutation, useQueryClient } from '@tanstack/react-query'

// List query
export const postsQueryOptions = queryOptions({
  queryKey: ['posts'],
  queryFn: async () => {
    const res = await fetch('/api/posts')
    return res.json() as Promise<Post[]>
  },
})

export const Route = createFileRoute('/posts/')({
  loader: ({ context: { queryClient } }) =>
    queryClient.ensureQueryData(postsQueryOptions),
  component: PostsListComponent,
})

function PostsListComponent() {
  const queryClient = useQueryClient()
  const { data: posts } = useQuery(postsQueryOptions)

  // Add post mutation
  const addPost = useMutation({
    mutationFn: async (newPost: NewPost) => {
      const res = await fetch('/api/posts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newPost),
      })
      return res.json()
    },
    onSuccess: () => {
      // Invalidate list after adding
      queryClient.invalidateQueries({ queryKey: ['posts'] })
    },
  })

  // Delete mutation
  const deletePost = useMutation({
    mutationFn: async (postId: string) => {
      await fetch(`/api/posts/${postId}`, { method: 'DELETE' })
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['posts'] })
    },
  })

  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts?.map((post) => (
          <li key={post.id}>
            <Link to="/posts/$postId" params={{ postId: post.id }}>
              {post.title}
            </Link>
            <button onClick={() => deletePost.mutate(post.id)}>
              Delete
            </button>
          </li>
        ))}
      </ul>
      <button onClick={() => addPost.mutate({ title: 'New Post' })}>
        Add Post
      </button>
    </div>
  )
}
```

### Pattern 4: Search Params + Dependent Queries

**Dynamic queries** based on URL search params:

```typescript
// src/routes/posts.index.tsx
import { createFileRoute } from '@tanstack/react-router'
import { queryOptions, useQuery } from '@tanstack/react-query'
import { z } from 'zod'
import { zodValidator, fallback } from '@tanstack/zod-adapter'

const searchSchema = z.object({
  page: fallback(z.number().int().positive(), 1),
  filter: fallback(z.string(), ''),
  sort: fallback(z.enum(['newest', 'oldest', 'popular']), 'newest'),
})

// Query depends on search params
export const postsQueryOptions = (search: z.infer<typeof searchSchema>) =>
  queryOptions({
    queryKey: ['posts', search], // Key includes all params
    queryFn: async () => {
      const params = new URLSearchParams({
        page: String(search.page),
        filter: search.filter,
        sort: search.sort,
      })
      const res = await fetch(`/api/posts?${params}`)
      return res.json() as Promise<PostsResponse>
    },
  })

export const Route = createFileRoute('/posts/')({
  validateSearch: zodValidator(searchSchema),

  // Prefetch with current search params
  loader: ({ context: { queryClient }, search }) =>
    queryClient.ensureQueryData(postsQueryOptions(search)),

  component: PostsListComponent,
})

function PostsListComponent() {
  const navigate = Route.useNavigate()
  const search = Route.useSearch()

  // Query automatically refetches when search params change
  const { data, isPending } = useQuery(postsQueryOptions(search))

  return (
    <div>
      <input
        value={search.filter}
        onChange={(e) =>
          navigate({
            search: { ...search, filter: e.target.value, page: 1 },
          })
        }
        placeholder="Filter posts..."
      />

      {isPending ? (
        <div>Loading...</div>
      ) : (
        <ul>
          {data.posts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      )}

      {/* Pagination */}
      <button
        onClick={() =>
          navigate({ search: { ...search, page: search.page - 1 } })
        }
        disabled={search.page === 1}
      >
        Previous
      </button>
      <span>Page {search.page}</span>
      <button
        onClick={() =>
          navigate({ search: { ...search, page: search.page + 1 } })
        }
        disabled={!data.hasMore}
      >
        Next
      </button>
    </div>
  )
}
```

### Pattern 5: Prefetch on Link Hover

**Instant navigation** with aggressive prefetching:

```typescript
// src/routes/posts.index.tsx
import { createFileRoute, Link } from '@tanstack/react-router'
import { useQueryClient } from '@tanstack/react-query'
import { postQueryOptions } from './posts.$postId'

export const Route = createFileRoute('/posts/')({
  loader: ({ context: { queryClient } }) =>
    queryClient.ensureQueryData(postsQueryOptions),
  component: PostsListComponent,
})

function PostsListComponent() {
  const queryClient = useQueryClient()
  const { data: posts } = useQuery(postsQueryOptions)

  return (
    <ul>
      {posts?.map((post) => (
        <li key={post.id}>
          <Link
            to="/posts/$postId"
            params={{ postId: post.id }}
            // Prefetch on hover
            onMouseEnter={() => {
              queryClient.prefetchQuery(postQueryOptions(post.id))
            }}
          >
            {post.title}
          </Link>
        </li>
      ))}
    </ul>
  )
}
```

### Pattern 6: Optimistic Updates with useMutationState

**Instant UI feedback** while mutation is pending:

```typescript
// src/routes/todos.tsx
import { createFileRoute } from '@tanstack/react-router'
import {
  queryOptions,
  useQuery,
  useMutation,
  useMutationState,
  useQueryClient
} from '@tanstack/react-query'

const todosQueryOptions = queryOptions({
  queryKey: ['todos'],
  queryFn: async () => {
    const res = await fetch('/api/todos')
    return res.json() as Promise<Todo[]>
  },
})

export const Route = createFileRoute('/todos')({
  loader: ({ context: { queryClient } }) =>
    queryClient.ensureQueryData(todosQueryOptions),
  component: TodosComponent,
})

function TodosComponent() {
  const queryClient = useQueryClient()
  const { data: todos } = useQuery(todosQueryOptions)

  // Add todo mutation
  const addTodo = useMutation({
    mutationKey: ['addTodo'],
    mutationFn: async (newTodo: { title: string }) => {
      const res = await fetch('/api/todos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(newTodo),
      })
      return res.json()
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  // Get pending mutations for optimistic UI
  const pendingTodos = useMutationState({
    filters: { mutationKey: ['addTodo'], status: 'pending' },
    select: (mutation) => mutation.state.variables,
  })

  return (
    <div>
      <h1>Todos</h1>
      <ul>
        {/* Show saved todos */}
        {todos?.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}

        {/* Show pending todos with visual indicator */}
        {pendingTodos.map((todo, i) => (
          <li key={`pending-${i}`} style={{ opacity: 0.5, fontStyle: 'italic' }}>
            {todo.title} (saving...)
          </li>
        ))}
      </ul>

      <button onClick={() => addTodo.mutate({ title: 'New Todo' })}>
        Add Todo
      </button>
    </div>
  )
}
```

### Key Benefits of Integration

✅ **Type Safety**: Query keys and params automatically typed across router and queries  
✅ **Prefetching**: Data loads in loaders before component renders (faster UX)  
✅ **Cache Sharing**: Multiple routes can share same query data (no duplicate fetches)  
✅ **Invalidation**: Mutations can trigger refetches across routes  
✅ **SSR Ready**: Works with server-side rendering and streaming  
✅ **Suspense**: Use `useSuspenseQuery` for automatic loading states  
✅ **Optimistic UI**: Show pending mutations immediately with `useMutationState`

---

## TanStack Router + Query + Better Auth Integration

Complete authentication setup combining TanStack Router, TanStack Query, and Better Auth with SplashScreen validation and protected routes:

### Setup: Better Auth Client

**Install Dependencies**:

```bash
npm install better-auth @tanstack/react-query @tanstack/react-router
```

**Create Better Auth Client** (frontend):

```typescript
// src/lib/auth-client.ts
import { createAuthClient } from "better-auth/react";

export const authClient = createAuthClient({
  baseURL: import.meta.env.VITE_API_URL || "http://localhost:3000",
});

// Export hooks
export const { useSession, signIn, signUp, signOut } = authClient;

// SessionStorage key
const AUTH_FLAG_KEY = "isLoggedIn";

// Check if user has authenticated (flag in sessionStorage)
export function getAuthFlag(): boolean {
  return sessionStorage.getItem(AUTH_FLAG_KEY) === "true";
}

// Set auth flag after successful login
export function setAuthFlag(value: boolean) {
  if (value) {
    sessionStorage.setItem(AUTH_FLAG_KEY, "true");
  } else {
    sessionStorage.removeItem(AUTH_FLAG_KEY);
  }
}

// Clear auth flag on logout
export function clearAuthFlag() {
  sessionStorage.removeItem(AUTH_FLAG_KEY);
}
```

### App Setup with SplashScreen

**Main App Component** with authentication validation:

```typescript
// src/main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { App } from './App'
import './index.css'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
```

```typescript
// src/App.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { RouterProvider, createRouter } from '@tanstack/react-router'
import { useSession, getAuthFlag } from './lib/auth-client'
import { routeTree } from './routeTree.gen'
import { SplashScreen } from './components/SplashScreen'

// Create QueryClient
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      gcTime: 1000 * 60 * 60, // 1 hour
      refetchOnWindowFocus: false,
    },
  },
})

// Create Router with typed context
const router = createRouter({
  routeTree,
  context: {
    queryClient,
    session: undefined!, // Will be set by InnerApp
  },
  defaultPreload: 'intent',
})

// Type registration for autocomplete
declare module '@tanstack/react-router' {
  interface Register {
    router: typeof router
  }
}

// Inner app with auth validation
function InnerApp() {
  const { isPending, ...session } = useSession()
  const { user } = session

  // Check if user has authenticated before (flag in sessionStorage)
  const hasAuthFlag = getAuthFlag()

  // Show splash screen only if:
  // 1. User has authenticated before (flag exists in sessionStorage)
  // 2. Session is still loading (isPending)
  // 3. User data not loaded yet (!user)
  if (hasAuthFlag && isPending && !user) {
    return <SplashScreen />
  }

  return (
    <RouterProvider
      router={router}
      context={{
        session: { ...session, isLoggedIn: !!user },
        queryClient
      }}
    />
  )
}

// Main App with providers
export function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <InnerApp />
    </QueryClientProvider>
  )
}
```

### SplashScreen Component

**Loading UI** during auth validation (only shown when flag exists in sessionStorage):

```typescript
// src/components/SplashScreen.tsx

/**
 * SplashScreen is shown only when:
 * 1. User has authenticated before (isLoggedIn flag exists in sessionStorage)
 * 2. Better Auth is still validating the session (isPending = true)
 * 3. User data hasn't loaded yet (!user)
 *
 * This prevents showing splash screen to:
 * - First-time visitors (no flag)
 * - Users after logout (flag cleared)
 * - Users with expired sessions (flag cleared on 401)
 */
export function SplashScreen() {
  return (
    <div className="flex h-screen items-center justify-center bg-gradient-to-br from-purple-500 to-blue-600">
      <div className="text-center">
        <div className="mb-4 inline-block h-16 w-16 animate-spin rounded-full border-4 border-white border-t-transparent"></div>
        <h1 className="text-2xl font-bold text-white">Loading...</h1>
        <p className="mt-2 text-white/80">Validating your session</p>
      </div>
    </div>
  )
}
```

### Router Context Types

**Type-safe context** for all routes:

```typescript
// src/router.ts
import { QueryClient } from "@tanstack/react-query";

export interface RouterContext {
  queryClient: QueryClient;
  session: {
    user: {
      id: string;
      email: string;
      name?: string;
      image?: string;
    } | null;
    isLoggedIn: boolean;
    isPending: boolean;
    error: Error | null;
  };
}
```

### Root Route with Auth Context

**Root layout** with session access:

```typescript
// src/routes/__root.tsx
import { createRootRouteWithContext, Outlet } from '@tanstack/react-router'
import { TanStackRouterDevtools } from '@tanstack/router-devtools'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import type { RouterContext } from '../router'

export const Route = createRootRouteWithContext<RouterContext>()({
  component: RootComponent,
})

function RootComponent() {
  return (
    <>
      <Outlet />
      <ReactQueryDevtools initialIsOpen={false} />
      <TanStackRouterDevtools position="bottom-right" />
    </>
  )
}
```

### Protected Routes with beforeLoad

**Pattern 1: Single Protected Route**:

```typescript
// src/routes/dashboard.tsx
import { createFileRoute, redirect } from '@tanstack/react-router'

export const Route = createFileRoute('/dashboard')({
  // Protect route before loading
  beforeLoad: async ({ context }) => {
    if (!context.session.isLoggedIn) {
      throw redirect({
        to: '/login',
        search: {
          redirect: '/dashboard', // Save for post-login redirect
        },
      })
    }
  },

  component: DashboardComponent,
})

function DashboardComponent() {
  const { session } = Route.useRouteContext()

  return (
    <div>
      <h1>Dashboard</h1>
      <p>Welcome back, {session.user?.name}!</p>
    </div>
  )
}
```

**Pattern 2: Protected Layout Route** (protects all children):

```typescript
// src/routes/(authenticated)/route.tsx
import { createFileRoute, redirect, Outlet } from '@tanstack/react-router'
import { Navigation } from '@/components/Navigation'

export const Route = createFileRoute('/(authenticated)')({
  // Protect all child routes
  beforeLoad: async ({ context, location }) => {
    if (!context.session.isLoggedIn) {
      throw redirect({
        to: '/login',
        search: {
          redirect: location.pathname, // Save current path
        },
      })
    }
  },

  component: AuthenticatedLayout,
})

function AuthenticatedLayout() {
  const { session } = Route.useRouteContext()

  return (
    <div className="flex h-screen">
      {/* Sidebar navigation */}
      <Navigation user={session.user!} />

      {/* Main content */}
      <main className="flex-1 overflow-y-auto bg-gray-50 p-8">
        <Outlet />
      </main>
    </div>
  )
}
```

**Protected Child Routes** (automatically protected by layout):

```typescript
// src/routes/(authenticated)/profile.tsx
import { createFileRoute } from '@tanstack/react-router'
import { queryOptions, useQuery } from '@tanstack/react-query'

// Profile query with auth
const profileQueryOptions = queryOptions({
  queryKey: ['profile'],
  queryFn: async () => {
    const res = await fetch('/api/users/me', {
      credentials: 'include', // Send auth cookies
    })
    if (!res.ok) throw new Error('Failed to fetch profile')
    return res.json() as Promise<UserProfile>
  },
})

export const Route = createFileRoute('/(authenticated)/profile')({
  // Prefetch profile data
  loader: ({ context: { queryClient } }) =>
    queryClient.ensureQueryData(profileQueryOptions),

  component: ProfileComponent,
})

function ProfileComponent() {
  const { data: profile } = useQuery(profileQueryOptions)

  return (
    <div>
      <h1>Your Profile</h1>
      <div>
        <label>Email</label>
        <p>{profile.email}</p>
      </div>
      <div>
        <label>Name</label>
        <p>{profile.name}</p>
      </div>
    </div>
  )
}
```

```typescript
// src/routes/(authenticated)/settings.tsx
import { createFileRoute } from '@tanstack/react-router'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { signOut, clearAuthFlag } from '@/lib/auth-client'

export const Route = createFileRoute('/(authenticated)/settings')({
  component: SettingsComponent,
})

function SettingsComponent() {
  const queryClient = useQueryClient()
  const navigate = Route.useNavigate()

  const logout = useMutation({
    mutationFn: async () => {
      await signOut()
    },
    onSuccess: () => {
      // Clear auth flag from sessionStorage
      clearAuthFlag()

      // Clear all queries and redirect
      queryClient.clear()
      navigate({ to: '/login' })
    },
  })

  return (
    <div>
      <h1>Settings</h1>
      <button
        onClick={() => logout.mutate()}
        disabled={logout.isPending}
        className="rounded bg-red-600 px-4 py-2 text-white hover:bg-red-700"
      >
        {logout.isPending ? 'Logging out...' : 'Logout'}
      </button>
    </div>
  )
}
```

### Public Routes (Login/Register)

**Login page** with post-auth redirect:

```typescript
// src/routes/login.tsx
import { createFileRoute, redirect, useNavigate } from '@tanstack/react-router'
import { useMutation } from '@tanstack/react-query'
import { signIn, setAuthFlag } from '@/lib/auth-client'
import { z } from 'zod'
import { zodValidator, fallback } from '@tanstack/zod-adapter'

const loginSearchSchema = z.object({
  redirect: fallback(z.string(), '/dashboard'),
})

export const Route = createFileRoute('/login')({
  validateSearch: zodValidator(loginSearchSchema),

  // Redirect if already logged in
  beforeLoad: async ({ context, search }) => {
    if (context.session.isLoggedIn) {
      throw redirect({ to: search.redirect })
    }
  },

  component: LoginComponent,
})

function LoginComponent() {
  const navigate = useNavigate()
  const search = Route.useSearch()

  const loginMutation = useMutation({
    mutationFn: async (data: { email: string; password: string }) => {
      const result = await signIn.email({
        email: data.email,
        password: data.password,
      })
      if (!result.data) throw new Error(result.error?.message || 'Login failed')
      return result.data
    },
    onSuccess: () => {
      // Set auth flag in sessionStorage to prevent SplashScreen on reload
      setAuthFlag(true)

      // Redirect to saved location or dashboard
      navigate({ to: search.redirect })
    },
  })

  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    const formData = new FormData(e.currentTarget)
    loginMutation.mutate({
      email: formData.get('email') as string,
      password: formData.get('password') as string,
    })
  }

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-100">
      <div className="w-full max-w-md rounded-lg bg-white p-8 shadow-lg">
        <h1 className="mb-6 text-2xl font-bold">Sign In</h1>

        <form onSubmit={handleSubmit} className="space-y-4">
          <div>
            <label htmlFor="email" className="block text-sm font-medium">
              Email
            </label>
            <input
              type="email"
              name="email"
              id="email"
              required
              className="mt-1 w-full rounded border px-3 py-2"
            />
          </div>

          <div>
            <label htmlFor="password" className="block text-sm font-medium">
              Password
            </label>
            <input
              type="password"
              name="password"
              id="password"
              required
              className="mt-1 w-full rounded border px-3 py-2"
            />
          </div>

          {loginMutation.error && (
            <div className="rounded bg-red-50 p-3 text-sm text-red-600">
              {loginMutation.error.message}
            </div>
          )}

          <button
            type="submit"
            disabled={loginMutation.isPending}
            className="w-full rounded bg-blue-600 py-2 text-white hover:bg-blue-700 disabled:opacity-50"
          >
            {loginMutation.isPending ? 'Signing in...' : 'Sign In'}
          </button>
        </form>

        <p className="mt-4 text-center text-sm text-gray-600">
          Don't have an account?{' '}
          <a href="/register" className="text-blue-600 hover:underline">
            Sign up
          </a>
        </p>
      </div>
    </div>
  )
}
```

### Navigation Component with Auth

**Sidebar navigation** showing user info:

```typescript
// src/components/Navigation.tsx
import { Link, useNavigate } from '@tanstack/react-router'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { signOut, clearAuthFlag } from '@/lib/auth-client'

interface NavigationProps {
  user: {
    id: string
    email: string
    name?: string
    image?: string
  }
}

export function Navigation({ user }: NavigationProps) {
  const queryClient = useQueryClient()
  const navigate = useNavigate()

  const logout = useMutation({
    mutationFn: async () => {
      await signOut()
    },
    onSuccess: () => {
      // Clear auth flag from sessionStorage
      clearAuthFlag()

      queryClient.clear()
      navigate({ to: '/login' })
    },
  })

  return (
    <aside className="flex w-64 flex-col border-r bg-white">
      {/* User info */}
      <div className="border-b p-4">
        <div className="flex items-center gap-3">
          {user.image ? (
            <img
              src={user.image}
              alt={user.name || 'User'}
              className="h-10 w-10 rounded-full"
            />
          ) : (
            <div className="flex h-10 w-10 items-center justify-center rounded-full bg-purple-600 text-white">
              {user.name?.[0]?.toUpperCase() || user.email[0].toUpperCase()}
            </div>
          )}
          <div className="flex-1 overflow-hidden">
            <p className="truncate font-medium">{user.name || 'User'}</p>
            <p className="truncate text-sm text-gray-500">{user.email}</p>
          </div>
        </div>
      </div>

      {/* Navigation links */}
      <nav className="flex-1 space-y-1 p-4">
        <Link
          to="/dashboard"
          className="block rounded px-4 py-2 hover:bg-gray-100"
          activeProps={{ className: 'bg-purple-50 text-purple-700' }}
        >
          Dashboard
        </Link>
        <Link
          to="/profile"
          className="block rounded px-4 py-2 hover:bg-gray-100"
          activeProps={{ className: 'bg-purple-50 text-purple-700' }}
        >
          Profile
        </Link>
        <Link
          to="/settings"
          className="block rounded px-4 py-2 hover:bg-gray-100"
          activeProps={{ className: 'bg-purple-50 text-purple-700' }}
        >
          Settings
        </Link>
      </nav>

      {/* Logout button */}
      <div className="border-t p-4">
        <button
          onClick={() => logout.mutate()}
          disabled={logout.isPending}
          className="w-full rounded px-4 py-2 text-left text-red-600 hover:bg-red-50 disabled:opacity-50"
        >
          {logout.isPending ? 'Logging out...' : 'Logout'}
        </button>
      </div>
    </aside>
  )
}
```

### Protected API Queries

**Fetch with auth credentials**:

```typescript
// src/lib/api.ts
import { clearAuthFlag } from "./auth-client";

export async function authenticatedFetch(
  url: string,
  options?: RequestInit,
): Promise<Response> {
  const res = await fetch(url, {
    ...options,
    credentials: "include", // Send auth cookies
    headers: {
      "Content-Type": "application/json",
      ...options?.headers,
    },
  });

  if (res.status === 401) {
    // Session expired, clear auth flag and redirect to login
    clearAuthFlag();
    window.location.href = "/login";
    throw new Error("Unauthorized");
  }

  return res;
}

// Usage in query
const todosQueryOptions = queryOptions({
  queryKey: ["todos"],
  queryFn: async () => {
    const res = await authenticatedFetch("/api/todos");
    return res.json() as Promise<Todo[]>;
  },
});
```

### Authentication Flow with SessionStorage Flag

**How the auth flag prevents unnecessary splash screens:**

1. **First Login** (no flag exists):
   - User visits app → No splash screen (no flag)
   - User clicks login → Enters credentials
   - Login success → `setAuthFlag(true)` saves flag in sessionStorage
   - Redirected to dashboard

2. **Page Reload** (flag exists):
   - User refreshes page → Checks flag with `getAuthFlag()`
   - Flag exists + session loading → Shows SplashScreen
   - Better Auth validates session with backend
   - Session valid → Renders app with user data
   - Session invalid → Backend returns 401 → `clearAuthFlag()` → Redirect to login

3. **Session Expiry**:
   - User makes authenticated request via `authenticatedFetch()`
   - Backend returns 401 (session expired)
   - `clearAuthFlag()` removes flag from sessionStorage
   - Redirect to `/login`
   - Next page load → No flag → No splash screen

4. **Manual Logout**:
   - User clicks logout button
   - `clearAuthFlag()` removes flag
   - `queryClient.clear()` removes cached data
   - Redirect to `/login`

**Why this approach?**

- ✅ Better UX: No flash screen for first-time visitors
- ✅ Better UX: No flash screen after logout
- ✅ Better UX: Shows flash screen only when reloading with active session
- ✅ Security: Real validation happens on backend (flag is just UX hint)
- ✅ Automatic cleanup: Flag removed on 401 or logout

### Key Features of This Integration

✅ **Smart SplashScreen**: Only shows when auth flag exists in sessionStorage (user logged in before)  
✅ **SessionStorage Flag**: Prevents unnecessary splash screen on every page reload  
✅ **Protected Routes**: Automatic redirect to login for unauthenticated users  
✅ **Post-Login Redirect**: Saves intended route and redirects after login  
✅ **Layout Protection**: Single `beforeLoad` protects all child routes  
✅ **Type-Safe Context**: Session data typed across all routes  
✅ **Query Integration**: Prefetch authenticated data in loaders  
✅ **Automatic Logout**: Clear cache, auth flag, and redirect on session expiry (401)  
✅ **Session Validation**: Real validation happens on backend via authenticated fetch  
✅ **Optimistic UI**: Better Auth hooks integrate with TanStack Query state

### File Structure

```
src/
├── routes/
│   ├── __root.tsx                 → Root layout with devtools
│   ├── index.tsx                  → Public home page
│   ├── login.tsx                  → Login page with redirect
│   ├── register.tsx               → Registration page
│   └── (authenticated)/
│       ├── route.tsx              → Protected layout (beforeLoad)
│       ├── dashboard.tsx          → Dashboard (auto-protected)
│       ├── profile.tsx            → Profile with data fetching
│       └── settings.tsx           → Settings with logout
├── components/
│   ├── SplashScreen.tsx           → Loading screen during auth check
│   └── Navigation.tsx             → Sidebar with user info
├── lib/
│   ├── auth-client.ts             → Better Auth client setup
│   └── api.ts                     → Authenticated fetch helper
├── App.tsx                        → App with SplashScreen logic
├── main.tsx                       → React root
└── router.ts                      → Router context types
```

---

## Virtual File Routes (v1.140+)

Programmatic route configuration when file-based conventions don't fit your needs:

**Install**: `npm install @tanstack/virtual-file-routes`

**Vite Config**:

```typescript
import { tanstackRouter } from "@tanstack/router-plugin/vite";

export default defineConfig({
  plugins: [
    tanstackRouter({
      target: "react",
      virtualRouteConfig: "./routes.ts", // Point to your routes file
    }),
    react(),
  ],
});
```

**routes.ts** (define routes programmatically):

```typescript
import {
  rootRoute,
  route,
  index,
  layout,
  physical,
} from "@tanstack/virtual-file-routes";

export const routes = rootRoute("root.tsx", [
  index("home.tsx"),
  route("/posts", "posts/posts.tsx", [
    index("posts/posts-home.tsx"),
    route("$postId", "posts/posts-detail.tsx"),
  ]),
  layout("first", "layout/first-layout.tsx", [route("/nested", "nested.tsx")]),
  physical("/classic", "file-based-subtree"), // Mix with file-based
]);
```

**Use Cases**: Custom route organization, mixing file-based and code-based, complex nested layouts.

---

## Search Params Validation (Zod Adapter)

Type-safe URL search params with runtime validation:

**Basic Pattern** (inline validation):

```typescript
import { z } from "zod";

export const Route = createFileRoute("/products")({
  validateSearch: (search) =>
    z
      .object({
        page: z.number().catch(1),
        filter: z.string().catch(""),
        sort: z.enum(["newest", "oldest", "price"]).catch("newest"),
      })
      .parse(search),
});
```

**Recommended Pattern** (Zod adapter with fallbacks):

```typescript
import { zodValidator, fallback } from "@tanstack/zod-adapter";
import { z } from "zod";

const searchSchema = z.object({
  query: z.string().min(1).max(100),
  page: fallback(z.number().int().positive(), 1),
  sortBy: z.enum(["name", "date", "relevance"]).optional(),
});

export const Route = createFileRoute("/search")({
  validateSearch: zodValidator(searchSchema),
  // Type-safe: Route.useSearch() returns typed params
});
```

**Why `.catch()` over `.default()`**: Use `.catch()` to silently fix malformed params. Use `.default()` + `errorComponent` to show validation errors.

---

## Error Boundaries

Handle errors at route level with typed error components:

**Route-Level Error Handling**:

```typescript
export const Route = createFileRoute('/posts/$postId')({
  loader: async ({ params }) => {
    const post = await fetchPost(params.postId)
    if (!post) throw new Error('Post not found')
    return { post }
  },
  errorComponent: ({ error, reset }) => (
    <div>
      <p>Error: {error.message}</p>
      <button onClick={reset}>Retry</button>
    </div>
  ),
})
```

**Default Error Component** (global fallback):

```typescript
const router = createRouter({
  routeTree,
  defaultErrorComponent: ({ error }) => (
    <div className="error-page">
      <h1>Something went wrong</h1>
      <p>{error.message}</p>
    </div>
  ),
})
```

**Not Found Handling**:

```typescript
export const Route = createFileRoute('/posts/$postId')({
  notFoundComponent: () => <div>Post not found</div>,
})
```

---

## Authentication with beforeLoad

Protect routes before they load (no flash of protected content):

**Single Route Protection**:

```typescript
import { redirect } from "@tanstack/react-router";

export const Route = createFileRoute("/dashboard")({
  beforeLoad: async ({ context }) => {
    if (!context.auth.isAuthenticated) {
      throw redirect({
        to: "/login",
        search: { redirect: location.pathname }, // Save for post-login
      });
    }
  },
});
```

**Protect Multiple Routes** (layout route pattern):

```typescript
// routes/(authenticated)/route.tsx - protects all children
export const Route = createFileRoute("/(authenticated)")({
  beforeLoad: async ({ context }) => {
    if (!context.auth.isAuthenticated) {
      throw redirect({ to: "/login" });
    }
  },
});
```

**Passing Auth Context** (from React hooks):

```typescript
// main.tsx - pass auth state to router
function App() {
  const auth = useAuth() // Your auth hook

  return (
    <RouterProvider
      router={router}
      context={{ auth }} // Available in beforeLoad
    />
  )
}
```

---

## Known Issues Prevention

This skill prevents **20** documented issues:

### Issue #1: Devtools Dependency Resolution

- **Error**: Build fails with `@tanstack/router-devtools-core` not found
- **Fix**: `npm install @tanstack/router-devtools`

**Issue #2: Vite Plugin Order** (CRITICAL)

- **Error**: Routes not auto-generated, `routeTree.gen.ts` missing
- **Fix**: TanStackRouterVite MUST come before react() in plugins array
- **Why**: Plugin processes route files before React compilation

**Issue #3: Type Registration Missing**

- **Error**: `<Link to="...">` not typed, no autocomplete
- **Fix**: Import `routeTree` from `./routeTree.gen` in main.tsx to register types

**Issue #4: Loader Not Running**

- **Error**: Loader function not called on navigation
- **Fix**: Ensure route exports `Route` constant: `export const Route = createFileRoute('/path')({ loader: ... })`

**Issue #5: Memory Leak with TanStack Form** (FIXED)

- **Error**: Production crashes when using TanStack Form + Router
- **Source**: GitHub Issue #5734 (closed Jan 5, 2026)
- **Resolution**: Fixed in latest versions of @tanstack/form and @tanstack/react-start. Update both packages to resolve.

**Issue #6: Virtual Routes Index/Layout Conflict**

- **Error**: route.tsx and index.tsx conflict when using `physical()` in virtual routing
- **Source**: GitHub Issue #5421
- **Fix**: Use pathless route instead: `_layout.tsx` + `_layout.index.tsx`

**Issue #7: Search Params Type Inference**

- **Error**: Type inference not working with `zodSearchValidator`
- **Source**: GitHub Issue #3100 (regression since v1.81.5)
- **Fix**: Use `zodValidator` from `@tanstack/zod-adapter` instead

**Issue #8: TanStack Start Validators on Reload**

- **Error**: `validateSearch` not working on page reload in TanStack Start
- **Source**: GitHub Issue #3711
- **Note**: Works on client-side navigation, fails on direct page load

### Issue #9: Server Function Validation Errors Lose Structure

**Error**: `inputValidator` Zod errors stringified, losing structure on client
**Source**: [GitHub Issue #6428](https://github.com/TanStack/router/issues/6428)
**Why It Happens**: TanStack Start server function error serialization converts Zod issues array to JSON string in `error.message`, making it unusable without manual parsing.

**Prevention**:

```typescript
// Server function with input validation
export const myFn = createServerFn({ method: "POST" })
  .inputValidator(
    z.object({
      name: z.string().min(2),
      age: z.number().min(18),
    }),
  )
  .handler(async ({ data }) => data);

// Client: Workaround to parse stringified issues
try {
  await mutation.mutate({ data: invalidData });
} catch (error) {
  if (error.message.startsWith("[")) {
    const issues = JSON.parse(error.message);
    // Now can use structured error data
    issues.forEach((issue) => {
      console.log(issue.path, issue.message);
    });
  }
}
```

**Official Status**: Known issue, tracking PR for fix

### Issue #10: useParams({ strict: false }) Returns Unparsed Values

**Error**: Params typed as parsed but returned as strings after navigation
**Source**: [GitHub Issue #6385](https://github.com/TanStack/router/issues/6385)
**Why It Happens**: In v1.147.3+, `match.params` is no longer parsed when using `strict: false`. First render works correctly, but after navigation values are stored as strings instead of parsed types.

**Prevention**:

```typescript
// Route with param parsing
export const Route = createFileRoute("/posts/$postId")({
  params: {
    parse: (params) => ({
      postId: z.coerce.number().parse(params.postId),
    }),
  },
});

// Component: Use strict mode (default) for parsed params
function Component() {
  const { postId } = useParams(); // ✓ Parsed as number
  // const { postId } = useParams({ strict: false }) // ✗ String!

  // Or manually parse when using strict: false
  const params = useParams({ strict: false });
  const postId = Number(params.postId);
}
```

**Official Status**: Known issue, workaround required

### Issue #11: Pathless Route notFoundComponent Not Rendering

**Error**: `notFoundComponent` on pathless layout routes ignored
**Source**: [GitHub Issue #6351](https://github.com/TanStack/router/issues/6351), [GitHub Issue #4065](https://github.com/TanStack/router/issues/4065)
**Why It Happens**: Pathless routes (e.g., `routes/(authenticated)/route.tsx`) don't render their `notFoundComponent`. Instead, the `defaultNotFoundComponent` from router config is triggered. This has been broken since April 2025.

**Prevention**:

```typescript
// ✗ Doesn't work: notFoundComponent on pathless layout
export const Route = createFileRoute('/(authenticated)')({
  beforeLoad: ({ context }) => {
    if (!context.auth) throw redirect({ to: '/login' })
  },
  notFoundComponent: () => <div>Protected 404</div>, // Not rendered!
})

// ✓ Works: Define on child routes instead
export const Route = createFileRoute('/(authenticated)/dashboard')({
  notFoundComponent: () => <div>Protected 404</div>,
})
```

**Official Status**: Known issue, workaround required

### Issue #12: Aborted Loader Renders errorComponent with Undefined Error

**Error**: Rapid navigation aborts previous loader and renders errorComponent with `undefined` error
**Source**: [GitHub Issue #6388](https://github.com/TanStack/router/issues/6388)
**Why It Happens**: Side effect introduced after PR #4570. When user rapidly navigates (e.g., clicking through list items), aborted fetch requests trigger errorComponent without passing the abort error.

**Prevention**:

```typescript
export const Route = createFileRoute('/posts/$postId')({
  loader: async ({ params, abortController }) => {
    await fetch(`/api/posts/${params.postId}`, {
      signal: abortController.signal,
    })
  },
  errorComponent: ({ error, reset }) => {
    // Check for undefined error (aborted request)
    if (!error) {
      return null // Or show loading state
    }
    return <div>Error: {error.message}</div>
  },
})
```

**Official Status**: Known issue, workaround required

### Issue #13: Vitest Cannot Read Properties of Null (useState)

**Error**: `Cannot read properties of null (reading 'useState')` when running tests with Vitest
**Source**: [GitHub Issue #6262](https://github.com/TanStack/router/issues/6262), [PR #6074](https://github.com/TanStack/router/pull/6074)
**Why It Happens**: TanStack Start's `tanstackStart()` plugin conflicts with Vitest's React hooks rendering. This is a known duplicate issue with a PR in progress.

**Prevention**:

```typescript
// Temporary workaround: Comment out tanstackStart() for tests
// vite.config.ts
export default defineConfig({
  plugins: [
    // tanstackStart(), // Disable for tests
    react(),
  ],
  test: { environment: "jsdom" },
});
```

**Official Status**: PR #6074 in progress to fix

### Issue #14: Throwing Error in Streaming SSR Loader Crashes Dev Server

**Error**: Dev server crashes when route loader throws error without awaiting (using `void` instead of `await`)
**Source**: [GitHub Issue #6200](https://github.com/TanStack/router/issues/6200)
**Why It Happens**: SSR streaming mode can't handle unawaited promise rejections. The error escapes the loader context and crashes the worker process.

**Prevention**:

```typescript
// ✗ Wrong: void + throw crashes dev server
export const Route = createFileRoute("/posts")({
  loader: async () => {
    void fetch("/api/posts").then((r) => {
      throw new Error("boom"); // Crashes!
    });
  },
});

// ✓ Correct: Always await or catch
export const Route = createFileRoute("/posts")({
  loader: async () => {
    try {
      const data = await fetch("/api/posts");
      return data;
    } catch (error) {
      throw error; // Caught by errorComponent
    }
  },
});
```

**Official Status**: Known issue, workaround required

### Issue #15: Prerender Hangs Indefinitely if Filter Returns Zero Results

**Error**: Build step hangs when `prerender.filter` returns zero routes
**Source**: [GitHub Issue #6425](https://github.com/TanStack/router/issues/6425)
**Why It Happens**: TanStack Start prerendering doesn't handle empty route sets gracefully - it waits indefinitely for routes that never come.

**Prevention**:

```typescript
// ✗ Wrong: Empty filter causes hang
tanstackStart({
  prerender: {
    enabled: true,
    filter: (route) => false, // No routes → hangs!
  },
});

// ✓ Correct: Ensure at least one route or disable
tanstackStart({
  prerender: {
    enabled: true,
    filter: (route) => route.path === "/" || route.path.startsWith("/posts"),
  },
});

// Or temporarily disable
tanstackStart({
  prerender: { enabled: false },
});
```

**Official Status**: Known issue, workaround required

### Issue #16: Prerendering Does Not Work in Docker

**Error**: Build fails in Docker with "Unable to connect" during prerender step
**Source**: [GitHub Issue #6275](https://github.com/TanStack/router/issues/6275), [PR #6305](https://github.com/TanStack/router/pull/6305)
**Why It Happens**: Vite preview server used for prerendering is not accessible in Docker environment.

**Prevention**:

```typescript
// vite.config.ts - Make preview server accessible in Docker
export default defineConfig({
  preview: {
    host: true, // Bind to 0.0.0.0 instead of localhost
  },
  plugins: [
    devtools(),
    // nitro({ preset: "bun" }), // Remove temporarily if issues persist
    tanstackStart(),
    react(),
  ],
});
```

**Official Status**: PR #6305 in progress

### Issue #17: Route Head Function Executes Before Loader Finishes

**Error**: Meta tags generated with incomplete data when `head()` runs before `loader()`
**Source**: [GitHub Issue #6221](https://github.com/TanStack/router/issues/6221)
**Why It Happens**: The `head()` function can execute before the route `loader()` finishes, causing meta tags to use placeholder or undefined data.

**Prevention**:

```typescript
// ✗ Wrong: loaderData may not be available yet
export const Route = createFileRoute("/posts/$postId")({
  loader: async ({ params }) => {
    const post = await fetchPost(params.postId);
    return { post };
  },
  head: ({ loaderData }) => ({
    meta: [
      { title: loaderData.post.title }, // May be undefined!
    ],
  }),
});

// ✓ Correct: Explicitly await if needed
export const Route = createFileRoute("/posts/$postId")({
  loader: async ({ params }) => {
    const post = await fetchPost(params.postId);
    return { post };
  },
  head: async ({ loaderData }) => {
    await loaderData; // Ensure loaded
    return {
      meta: [{ title: loaderData.post.title }],
    };
  },
});
```

**Official Status**: Known issue, workaround required

### Issue #18: Virtual Routes Don't Support Manual Lazy Loading (Community-sourced)

**Error**: `createLazyFileRoute` automatically replaced with `createFileRoute` in virtual routes
**Source**: [GitHub Issue #6396](https://github.com/TanStack/router/issues/6396)
**Why It Happens**: Virtual file routes are designed for automatic code splitting only. Manual lazy routes are not supported - the plugin silently replaces them.

**Prevention**:

```typescript
// Virtual routes: Use automatic code splitting
// vite.config.ts
tanstackRouter({
  target: "react",
  virtualRouteConfig: "./routes.ts",
  autoCodeSplitting: true, // Use automatic splitting
});

// Don't use createLazyFileRoute in virtual routes
// It will be replaced with createFileRoute automatically
```

**Official Status**: By design (documented behavior)

### Issue #19: NavigateOptions Type Safety Inconsistency (Community-sourced)

**Error**: `NavigateOptions` type doesn't enforce required params like `useNavigate()` does
**Source**: [TkDodo's Blog: The Beauty of TanStack Router](https://tkdodo.eu/blog/the-beauty-of-tan-stack-router)
**Why It Happens**: Type definitions differ between runtime hook and type helper. `NavigateOptions` is less strict.

**Prevention**:

```typescript
// ✗ Wrong: NavigateOptions doesn't catch missing params
const options: NavigateOptions = {
  to: "/posts/$postId", // No TS error, but params required!
};

// ✓ Correct: Use useNavigate() return type
const navigate = useNavigate();
type NavigateFn = typeof navigate;
// Now type-safe across all usages
```

**Verified**: Cross-referenced with TanStack Query maintainer analysis

### Issue #20: Missing Leading Slash in Route Paths (Community-sourced)

**Error**: Routes fail to match when path defined without leading slash
**Source**: [Official Debugging Guide](https://tanstack.com/router/latest/docs/framework/react/how-to/debug-router-issues)
**Why It Happens**: Very common beginner mistake - using `'about'` instead of `'/about'` causes route matching failures.

**Prevention**:

```typescript
// ✗ Wrong: Missing leading slash
export const Route = createFileRoute("about")({
  /* ... */
});

// ✓ Correct: Always start with /
export const Route = createFileRoute("/about")({
  /* ... */
});
```

**Verified**: Official documentation, common debugging issue

---

## Cloudflare Workers Integration

**Vite Config** (add @cloudflare/vite-plugin):

```typescript
import { cloudflare } from "@cloudflare/vite-plugin";

export default defineConfig({
  plugins: [TanStackRouterVite(), react(), cloudflare()],
});
```

**API Routes Pattern** (fetch from Workers backend):

```typescript
// Worker: functions/api/posts.ts
export async function onRequestGet({ env }) {
  const { results } = await env.DB.prepare("SELECT * FROM posts").all();
  return Response.json(results);
}

// Router: src/routes/posts.tsx
export const Route = createFileRoute("/posts")({
  loader: async () => fetch("/api/posts").then((r) => r.json()),
});
```

---

## Related Skills & References

**Skills**:

- **tanstack-query**: Data fetching and server state management (see [TanStack Query Integration Examples](#tanstack-query-integration-examples))
- **fastify-better-auth**: Authentication and session management (see [TanStack Router + Query + Better Auth Integration](#tanstack-router--query--better-auth-integration))
- **react-hook-form-zod**: Form validation in auth and settings pages
- **frontend-design**: UI components for SplashScreen and Navigation
- **cloudflare-worker-base**: API backend for protected endpoints

**Packages**:

- **@tanstack/zod-adapter**: Search params validation with Zod
- **@tanstack/virtual-file-routes**: Programmatic route configuration
- **better-auth**: Type-safe authentication library
- **@tanstack/react-query**: Server state management

**Integration Examples in This Skill**:

1. [TanStack Query Integration Examples](#tanstack-query-integration-examples)
   - Setup with QueryClient context
   - Basic query + loader prefetch
   - useSuspenseQuery + ErrorBoundary
   - List + mutations with invalidation
   - Search params + dependent queries
   - Prefetch on link hover
   - Optimistic updates with useMutationState

2. [TanStack Router + Query + Better Auth Integration](#tanstack-router--query--better-auth-integration)
   - App setup with SplashScreen for auth validation
   - Router context with session state
   - Protected routes with beforeLoad middleware
   - Public routes (login/register) with redirect
   - Navigation component with user info and logout
   - Protected API queries with credential handling
   - Complete file structure example

---

**Last verified**: 2026-02-15 | **Skill version**: 3.0.0 | **Changes**: Added comprehensive TanStack Query integration examples (7 patterns) and complete Better Auth integration with SplashScreen, protected routes, and authenticated data fetching. Increased from 20 to 27 total documented patterns and error preventions.
